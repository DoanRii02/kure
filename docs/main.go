package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"strings"

	"github.com/GGP1/kure/commands/root"
	"github.com/atotto/clipboard"

	"github.com/spf13/cobra"
	"github.com/spf13/cobra/doc"
	"github.com/spf13/pflag"
)

// Utils to help developers update Kure's documentation.
// Remember to update the wiki if necessary.
// build "go build main.go" and execute "./main [flags] [args]"

func main() {
	cmd := flag.Bool("cmd", false, "specific command documentation")
	comp := flag.Bool("completion", false, "generate completion")
	summ := flag.Bool("summary", false, "commands summary")
	flag.Parse()

	if *cmd {
		if err := cmdDocs(os.Args); err != nil {
			log.Fatalf("failed generating %s documentation: %v", os.Args[1], err)
		}
	} else if *comp {
		if err := completion(os.Args); err != nil {
			log.Fatalf("failed generating %s completion: %v", os.Args[1], err)
		}
	} else if *summ {
		if err := summary(os.Args); err != nil {
			log.Fatalf("failed generating commands summary: %v", err)
		}
	}
}

// Generate a command's documentation and adapt it to the format used.
//
// TODO: Generate custom markdown documentation.
//
// The output generated by this command should NEVER be used to overwrite the
// existing documentation (until custom docs are used) as the format is not the same
// and the documentation may contain information that isn't specified in the command.
//
// Usage: main --cmd ls.
func cmdDocs(args []string) error {
	root := root.CmdForDocs()

	cmd, _, err := root.Find(args[2:])
	if err != nil {
		return err
	}

	return doc.GenMarkdown(cmd, os.Stdout)
}

// Generate code completion files. By default it generates all the files.
//
// Usage: main --completion bash.
func completion(args []string) error {
	root := root.CmdForDocs()

	if len(args) < 3 {
		err := root.GenBashCompletionFile("completion/bash.sh")
		err = root.GenFishCompletionFile("completion/fish.sh", true)
		err = root.GenPowerShellCompletionFile("completion/powershell.ps1")
		err = root.GenZshCompletionFile("completion/zsh.sh")
		return err
	}

	switch args[2] {
	case "bash":
		return root.GenBashCompletionFile("completion/bash.sh")
	case "fish":
		return root.GenFishCompletionFile("completion/fish.sh", true)
	case "powershell":
		return root.GenPowerShellCompletionFile("completion/powershell.ps1")
	case "zsh":
		return root.GenZshCompletionFile("completion/zsh.sh")
	}

	return nil
}

// Generate the wiki commands summary page.
// https://www.github.com/kure/wiki/Commands-summary
// TODO: script to update the page and push changes.
//
// Usage: main --summary copy.
func summary(args []string) error {
	root := root.CmdForDocs()
	docs := fmtSummary(root)

	if len(args) == 3 {
		if args[2] == "copy" {
			if err := clipboard.WriteAll(docs); err != nil {
				return err
			}
		}
	}

	if _, err := fmt.Fprint(os.Stdout, docs); err != nil {
		return err
	}
	return nil
}

func fmtSummary(cmd *cobra.Command) string {
	var (
		sb      strings.Builder
		subCmds func(*cobra.Command, string)
	)

	cmdAndFlags := func(c *cobra.Command) {
		sb.WriteString(fmt.Sprintf("%s ", c.Use))

		c.Flags().VisitAll(func(f *pflag.Flag) {
			if f.Shorthand != "" {
				f.Shorthand = fmt.Sprintf("-%s ", f.Shorthand)
			}
			sb.WriteString(fmt.Sprintf("[%s%s] ", f.Shorthand, f.Name))
		})
	}
	// Add subcommands and flags using recursion
	subCmds = func(cmd *cobra.Command, indent string) {
		// Add indent on each call
		indent += "    "
		for _, sub := range cmd.Commands() {
			sb.WriteString("\n" + indent)
			cmdAndFlags(sub)
			subCmds(sub, indent)
		}
	}

	sb.WriteString(`For further information about each each command, its flags and examples please visit the [commands folder](https://github.com/GGP1/kure/tree/master/docs/commands).
`)

	// Index
	for _, c := range cmd.Commands() {
		sb.WriteString(fmt.Sprintf("\n- [%s](#%s)", c.Name(), c.Name()))
	}
	// Separation
	sb.WriteString("\n\n\n")

	// Each command name and its flags
	for _, c := range cmd.Commands() {
		sb.WriteString(fmt.Sprintf("### %s\n```\n", c.Name()))
		cmdAndFlags(c)
		subCmds(c, "")
		sb.WriteString("\n```\n\n---\n\n")
	}

	return sb.String()
}
